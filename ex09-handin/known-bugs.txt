x When listening, the menu doesn't hang around anymore, but the
  interface freezes nonetheless.

x Because the DisconnectEvent MyTextEvent, it has to call its
  constructor with a length. This is ugly and a result of implementation
  inheritance. Bad.

- Exceptions are propagated further or editor is killed after printing
  stacktrace. -- No error handling.

- Just tagged stuff as Serializable without caring for the implications.

- Sometimes upon connecting after a disconnect:
  IllegalArgumentException: Invalid remove
  -- Does area.setText("") trigger TextRemoveEvent? Make an event
  instead, but also difficult.

- Some of the queue stuff would be better done with observer pattern.

x Sometimes after disconnecting message in both editors, sometimes not.

- Rename MyTextEvent to something

- Rename *replay* to *display*

- Make display queue and outqueue more specific

- With the boolean server flag, edits close to each other can be
  unintuitive. Priorities might fix it.

- Inserts into region to be deleted are thrown away. -- Not very nice.

- If the TextRemoveEvent were more intelligent (fx understand negative
  lengths), we might be able to merge some cases in xform.

- The transformer is not correct. -- Invalid inserts and removals
  happen.


- When a connected editor is shut down, the other side dies, too. There
  is no simple fix for that since we'd have to wait for the connection
  to be shut down properly before calling System.exit(0).

- It is possible to put DisconnectEvents in the queue (by pressing
  Disconnect), when the editors are not connected. As a result, they
  disconnect immediately after the next connection setup.

- There is no indication that an editor is listening or connected.
